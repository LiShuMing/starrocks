// This file is licensed under the Elastic License 2.0. Copyright 2021-present, StarRocks Inc.

#ifndef STARROCKS_STREAMING_HASH_MAP_H
#define STARROCKS_STREAMING_HASH_MAP_H

#include <algorithm>
#include <utility>

#include "exec/streaming/state/state_cache.h"
#include "exec/streaming/streaming_fdw.h"
#include "exprs/expr.h"
#include "runtime/mem_pool.h"
#include "runtime/runtime_state.h"
#include "runtime/types.h"

namespace starrocks::streaming {

// represents all aggs' data for one group by key.
using AggDataPtr = uint8_t*;

class StreamingHashMap {
public:
    StreamingHashMap(StateCacheRawPtr state_cache): _state_cache(state_cache) {
        _mem_pool = std::make_unique<MemPool>();
    }
    ~StreamingHashMap() = default;

    // Compute agg stats for input key columns.
    Status compute_agg_states(size_t chunk_size, const Columns& key_columns,
                              Buffer<AggDataPtr>* agg_states);

    // Get key from map, must only seek from cache only.
    Status get(const Slice& key, AggDataPtr* value);

    // Called by each barrier, clean up some states generated by the epoch.
    Status reset_by_barrier();

    // Get changed keys since last epoch.
    const SliceHashSet& changed_keys() const { return _changed_keys; }
private:
    uint32_t get_max_serialize_size(const Columns& key_columns) {
        uint32_t max_size = 0;
        for (const auto& key_column : key_columns) {
            max_size += key_column->max_one_element_serialize_size();
        }
        return max_size;
    }
    static void delete_agg_state_value(const CacheKey& key, void* value) {
        auto* state_value = (AggDataPtr)value;
        delete[] state_value;
    }

    AggDataPtr allocate_agg_state_value() {
        // TODO: how to avoid OOM?
        AggDataPtr data = new uint8_t[_agg_states_total_size];
        return data;
    }

    void serialize_keys(size_t chunk_size, const Columns& key_columns) {
        _keys_slice_sizes.assign(chunk_size, 0);
        uint32_t cur_max_one_row_size = get_max_serialize_size(key_columns);
        if (UNLIKELY(cur_max_one_row_size > _max_keys_size)) {
            _max_keys_size = cur_max_one_row_size;
            _mem_pool->clear();
            _keys_buffer = _mem_pool->allocate(_max_keys_size * chunk_size + vectorized::SLICE_MEMEQUAL_OVERFLOW_PADDING);
        }
        for (const auto& key_column : key_columns) {
            key_column->serialize_batch(_keys_buffer, _keys_slice_sizes, chunk_size, _max_keys_size);
        }
    }
    Slice get_serialized_key(size_t i) { return {_keys_buffer + i * _max_keys_size, _keys_slice_sizes[i]}; }

private:
    StateCacheRawPtr _state_cache;
    // Current epoch which is used as the watermark, the entry(old state) less than the epoch can be evicted.
    Epoch _cur_epoch;
    // Store buffers which can be reused in the incremental compute.
    std::unique_ptr<MemPool> _mem_pool;

    // Max serialized size for all group_by keys.
    uint32_t _max_keys_size = 8;
    // Buffer which is used to store group_by keys that can be reused for each chunk.
    uint8_t* _keys_buffer;
    // Group_by keys' serialized sizes for each chunk.
    Buffer<uint32_t> _keys_slice_sizes;
    // Changed group by keys to generate outputs
    SliceHashSet _changed_keys;
    // The total size of the row for the aggregate function state.
    size_t _agg_states_total_size = 0;;
};

} // namespace starrocks

#endif //STARROCKS_STREAMING_HASH_MAP_H
